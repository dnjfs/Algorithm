//ACM-ICPC 2015 예선 B번 카드 게임
//백준 11062

#include "iostream"

using namespace std;

int p1[1000][1000], p2[1000][1000]; //첫번째.두번째 플레이어의 최선의 점수, p1[j][i]: 첫번째 플레이어의 구간 j~i에서 최선의 점수
int main()
{
	int T; //테스트 케이스
	cin >>T;
	while(T--)
	{
		int N; //카드의 개수
		cin >>N;
		for(int i = 0; i < N; i++)
			cin >>p1[i][i]; //카드 하나일 땐 첫번째 플레이어가 먼저 카드를 선택할 수 있음

		for(int i = 1; i < N; i++)
			for(int j = i-1; j >= 0; j--) //j~i 구간에서 카드 게임
			{
				int left = p1[j][j]+p2[j+1][i], right = p2[j][i-1]+p1[i][i]; //왼쪽/오른쪽 카드를 먼저 선택한 경우 최선의 점수
				if(left < right) //오른쪽 카드를 먼저 선택했을 때 점수가 더 큰 경우
				{
					p1[j][i] = right;
					p2[j][i] = p1[j][i-1];
				}
				else //왼쪽 카드를 먼저 선택했을 때 점수가 더 큰 경우
				{
					p1[j][i] = left;
					p2[j][i] = p1[j+1][i];
				}
			}

		cout <<p1[0][N-1] <<endl; //모든 카드가 있는 구간에서 첫번째 플레이어의 최선의 점수
	}
}



/*
일렬로 놓아진 카드에서 두 플레이어가 번갈아가며 맨 왼쪽 또는 맨 오른쪽 카드를 최선의 전략으로 가져가며 높은 점수를 만드는 문제입니다.
얼마 전에 풀었던 파일 합치기 문제와 비슷한 유형이라 2차원 배열을 사용하는 DP로 쉽게 해결할 수 있었습니다.
다만 문제 해결을 위해 첫번째 플레이어와 두번째 플레이어의 최선의 점수를 나눠야하여 똑같은 크기의 배열을 하나 더 만들었습니다.

left에 대입된 p1[j][j]+p2[j+1][i]에서 p1[j][j]는 j~i 구간에서 왼쪽 카드를 선택하여 얻은 점수이며,
첫번째 플레이어가 카드를 선택하였으니 남은 (j+1)~i 구간에서는 두번째 플레이어가 먼저 카드를 선택할 것입니다.
따라서 j~i 구간에서 후순위로 카드를 뽑던 플레이어가 (j+1)~i 구간에서는 첫번째 플레이어처럼 카드를 선택하므로 최선의 점수는 p1[j+1][i]와 같아질 것이고,
j~i 구간에서 첫번째 플레이어는 두번째 플레이어처럼 카드를 선택하므로 최선의 점수는 p1[j][j]+p2[j+1][i]와 같아집니다.
시간복잡도는 O(N^2)로 N의 최대 크기가 1000이라 무난하게 해결할 수 있습니다.
*/