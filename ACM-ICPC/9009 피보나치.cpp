//ACM-ICPC 2012 예선 D번 피보나치
//백준 9009

#include "iostream"

using namespace std;

int main()
{
	int T; //테스트 케이스
	cin >>T;
	while (T--)
	{
		int n, cnt = 0, ans[30], fib[45] ={ 1, 1 };
		/*
		n: 피보나치 수들의 합으로 나타낼 수
		cnt: 배열 인덱스
		ans[]: 출력할 피보나치 수 배열(스택)
		fib[]: 피보나치 수열
		*/
		cin >>n;

		int i;
		for (i = 2; fib[i-1] < n; i++) //피보나치 수열 생성, n보다 큰 수는 만들 필요 없음
			fib[i] = fib[i-1] + fib[i-2];

		while (n) //피보나치 수를 모두 찾을 때까지 반복(n이 0이 될 때까지)
		{
			while (fib[--i] > n); //n보다 작으면서 가장 큰 피보나치 수를 찾음

			n -= fib[i];
			ans[++cnt] = fib[i]; //출력할 배열에 피보나치 수 추가
		}

		while (cnt) //피보나치 수 오름차순으로 출력
			cout <<ans[cnt--] <<" ";
		cout <<endl;
	}
}



/*
양의 정수 하나를 입력받아 최소 개수의 피보나치 수의 합으로 나타내는 문제입니다.
n을 입력받은 것에서 n보다 작으면서 가장 큰 피보나치 수열을 선택하여
그 수를 다시 n을 빼는 것을 반복하여 피보나치 수를 찾을 수 있습니다.
n보다 작으면서 가장 큰 피보나치 수를 선택한 이유는 피보나치 수는 연속한 두 수를 합한 것이므로
그리디로 현재 선택할 수 있는 가장 큰 피보나치 수를 선택하면 최소 개수의 피보나치 수의 합으로 나타낼 수 있습니다.
*/