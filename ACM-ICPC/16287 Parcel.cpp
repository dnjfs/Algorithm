//ACM-ICPC 2018 예선 F번 Parcel
//백준 16287

#include "iostream"

using namespace std;

bool sum[800000]; //미리 합한 두 수를 저장하는 배열
int main()
{
	int w, n, A[5000];
	/*
	w: 물품의 무게 합
	n: 물품의 개수
	A[]: 물픔의 무게 배열
	*/

	cin >>w >>n;
	for(int i = 0; i < n; i++)
		cin >>A[i];

	for(int i = 0; i < n; i++)
	{
		for(int j = i+1; j < n; j++) //i번째 물품과 (i+1 ~ n-1)번째 물품을 합한 것이
			if(A[i]+A[j] < w && sum[w-A[i]-A[j]]) //w보다 작고 미리 합을 해둔 것이 있다면
			{
				cout <<"YES"; //조건 만족
				return 0;
			}
		
		for(int j = 0; j < i; j++) //i번째 물품과 (0 ~ i-1)번째 물품을 합한 것이
			if(A[i]+A[j] < w) //w보다 작다면
				sum[A[i]+A[j]] = true; //배열에 저장
	}

	cout <<"NO" <<endl; //모든 경우의 수를 다 찾아도 없는 경우
}




/*
n개의 물품 중 네 개를 선택한 무게가 w와 같아 무료 배송 조건을 만족하는지 여부를 출력하는 문제입니다.
2019.12.28에 풀었던 문제지만 재채점 기준에 미달되어 다시 풀게 되었습니다.
시간 제한이 4초에서 1초로 줄어들어 1.2초가 나온 O(n^2 * log n)의 시간복잡도로는 시간 초과가 나와서 더 최적화된 코드로 바꿔야했습니다.
multimap을 이용하여 정렬하는 시간을 줄여볼까 했지만 원소를 넣을 때 시간이 걸리는지 이 방법도 시간 초과가 나왔습니다.
방법을 계속 고민했지만 답이 나오지 않아 구글링을 하였는데, DP를 이용한 것 같은 코드가 O(n^2)의 시간복잡도로 해결한 걸 발견했습니다.

A+B+C+D = w 식을 A+B = w-(C+D) 식으로 생각하여 풀이하였습니다.
코드에서 31번째 줄 for문은 A+B를 나타내고 24번째 줄 for문은 C+D를 나타냅니다.
A+B를 미리 배열에 저장해두고, 그 후 i를 증가시키며 C+D를 구하면 서로 범위가 달라 겹치지 않는 네 개의 물품을 선택할 수 있습니다.
*/
