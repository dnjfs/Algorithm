//백준 14003 가장 긴 증가하는 부분 수열 5

#include "iostream"
#include "vector"
#include "algorithm"
#define SIZE 1e6 //1000000

using namespace std;

vector<int> A(SIZE), C = {-1000000001}, p(SIZE), st(SIZE);
/*
A[]: 수열
C[i]: 부분 수열의 i번째 자리에 올 수 있는 가장 작은 원소
p[i]: A[i]가 부분 수열에 놓이는 위치
st[]: 부분 수열을 출력할 스택
*/
int main()
{
	int N, cnt = 0, idx = -1; //수열 A의 크기, 부분 수열의 길이, 스택의 인덱스
	cin >>N;
	for(int i = 0; i < N; i++)
	{
		cin >>A[i];

		if(A[i] > C.back()) //현재까지의 부분 수열의 가장 큰 수보다 더 큰 수가 입력된 경우
		{
			C.push_back(A[i]); //부분 수열에 추가
			p[i] = ++cnt; //부분 수열의 길이 증가
		}
		else
		{
			int l = lower_bound(C.begin(), C.end(), A[i]) - C.begin(); //이진탐색을 하여 부분 수열에서 A[i]보다 큰 원소가 처음 나타나는 위치를 찾음
			C[l] = A[i]; //부분 수열의 l번째 값을 원래 있던 값보다 작은 값으로 덮어씌워 부분 수열에 들어갈 원소의 값을 낮춤
			p[i] = l; //A[i]는 부분 수열의 l번째에 위치
		}
	}
	
	cout <<cnt <<endl; //가장 긴 증가하는 부분 수열의 길이 출력
	for(int i = N-1; i >= 0; i--) //수열 A를 거꾸로 탐색하며
		if(p[i] == cnt) //A[i]가 부분 수열의 cnt번째 위치해있으면
		{
			st[++idx] = A[i]; //스택에 저장
			cnt--; //부분 수열의 cnt번째를 찾았으니 (cnt-1)번째를 찾기 위해 감소시킴
		}
	while(idx >= 0)
		cout <<st[idx--] <<" "; //가장 긴 증가하는 부분 수열 출력
}




/*
가장 긴 증가하는 부분 수열 4(백준 14002)에서 수열의 크기가 1000000으로 증가하고 원소의 범위도 증가한 문제입니다.
가장 긴 증가하는 부분 수열(백준 11053)에서 가장 긴 증가하는 부분 수열 2(백준 12015)로 넘어갔을 때처럼
O(N^2)의 시간복잡도는 시간 초과가 발생하여 O(N logN)의 시간복잡도로 구현해야합니다.

p[] 배열을 만들어 수열 A[i]의 값이 부분 수열의 몇 번째에 위치해있는지 저장합니다.
부분 수열을 모두 찾았다면 부분 수열의 위치에 맞는 수열 A의 원소를 큰 값부터 찾아내어 스택에 저장하여 출력해줍니다.
작은 값부터 찾아내지 않는 이유는 부분 수열을 찾는 과정에서 더 작은 값으로 업데이트될 수 있기 때문입니다.
예를 들어 {1 50 100 5 10 20}과 같은 수열이 입력된 경우에 100까지는 부분 수열이 {1 50 100}이었지만,
5를 50의 자리에 놓으며 부분 수열을 {1 5}로 놓고 다시 찾는 것이 더 긴 부분 수열을 찾을 수 있습니다.
*/