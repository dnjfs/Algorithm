//백준 15990 1, 2, 3 더하기 5

#include "iostream"

using namespace std;

const int MOD = 1000000009;
int dp[100001][4] = {{0,1,1,1}, {1,1,0,0}, {1,0,1,0}, {3,1,1,1}}; //dp[i][j]: i를 j로 끝나는 합으로 나타내는 방법의 수
int main()
{
	int T;
	cin >>T;
	while(T--)
	{
		int n;
		cin >>n;

		for(int i = 4; i <= n; i++)
		{
			dp[i][1] = (dp[i-1][2] + dp[i-1][3]) % MOD; //(i-1)에서 2와 3으로 끝나는 수에 1을 더함
			dp[i][2] = (dp[i-2][1] + dp[i-2][3]) % MOD; //(i-2)에서 1과 3으로 끝나는 수에 2를 더함
			dp[i][3] = (dp[i-3][1] + dp[i-3][2]) % MOD; //(i-3)에서 1과 2로 끝나는 수에 3을 더함
		}
		cout <<(dp[n][1]+(dp[n][2]+dp[n][3])%MOD)%MOD <<endl; //n을 1과 2와 3으로 끝나는 수의 합으로 나타내는 방법의 수를 모두 더함
	}
	cout <<"5 " <<dp[5][2];
}




/*
1, 2, 3 더하기 3(백준 15988)의 문제에서 같은 수를 연속해서 사용하면 안 된다는 조건이 추가된 문제입니다.
그래서 1을 더하기 위해 정수 (i-1)을 1과 2와 3의 합으로 나타내는 방법 중 2와 3으로 끝나는 수를 찾아 1을 더해주고,
2와 3도 비슷한 방법으로 같은 수가 연속되지 않도록 더해줍니다.
8번째 줄에서 dp[i][j] 배열엔 i를 j로 끝나는 합으로 나타내는 방법의 수가 저장되어 있다고 했는데,
예를 들어 dp[5][2]라면 2+1+2, 3+2처럼 합의 크기가 5인 수에서 2로 끝나는 합을 만드는 방법의 수입니다.
*/