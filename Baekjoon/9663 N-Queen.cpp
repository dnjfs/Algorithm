//백준 9663 N-Queen
//solved.ac CLASS 4

#include "iostream"

using namespace std;

int Q[14], N, ans; //Q[r]: r행에 놓인 퀸의 열의 위치, 체스판의 크기, 퀸을 놓는 방법의 수
void pos(int r) //r행에 퀸 놓기 시도
{
	if(r == N) //모든 행에 퀸을 놓았음
	{
		ans++;
		return;
	}

	for(int c = 0; c < N; c++) //열을 한 칸씩 옮기며 퀸 놓기
	{
		int i = 1;
		for( ; i <= r; i++) //r행과 (r-1)~0행의 퀸이 서로 공격할 수 있는지 검사
			if(Q[r-i] == c-i || Q[r-i] == c || Q[r-i] == c+i) //왼쪽 위 대각선, 위쪽 직선, 오른쪽 위 대각선
				break;

		Q[r] = c; //r행c열에 퀸을 놓음
		if(i > r) //현재 행까지 모든 퀸이 서로 공격할 수 없는 경우
			pos(r+1); //그 다음 행에서도 퀸 놓기 시도
	}
}

int main()
{
	cin >>N;

	pos(0);
	cout <<ans;
}




/*
크기가 NxN인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓을 때 퀸을 놓는 방법의 수를 구하는 문제입니다.
백트래킹을 이용하여 퀸을 놓을 수 있는 상황이면 더 진행하고, 퀸을 더 놓을 수 없는 상황에는 이전으로 돌아오는 식으로 해결하였습니다.
시간이 10초나 주어졌지만 단순히 모든 경우의 수를 보면 N^N의 시도를 하게 되어 모든 경우의 수를 확인하지 않도록 최적화를 잘해야 합니다.

퀸이 공격할 수 있는 방향은 상하좌우와 대각선으로 8방향이지만 현재 상태에서 가장 아래쪽 행에 퀸을 놓을 경우에
좌우와 그 밑의 행은 퀸이 놓여있지 않는 게 확실하므로 왼쪽 위, 위쪽, 오른쪽 위 3방향만 겹치는지 검사하면 됩니다.
Q[] 배열에는 인덱스에 해당하는 행의 어느 열에 퀸이 놓여있는지 저장되어 있으므로,
r행 c열의 퀸이 (r-1), (r-2), ..., 0행에 놓인 퀸을 공격할 수 있는지 검사합니다.
검사를 모두 마친 경우엔 (r+1)행에서도 동일한 방법으로 퀸을 놓아보고,
검사를 모두 마치지 못하거나 (r+1)행에서 퀸을 놓고 다시 돌아온 경우 r행 (c+1)열에 퀸을 놓아봅니다.
*/