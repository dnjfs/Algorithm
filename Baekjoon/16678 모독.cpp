//백준 16678 모독

#include "iostream"
#include "algorithm"

using namespace std;

int a[100000]; //국회의원의 명예 점수
int main()
{
	int N; //국회의원의 명수
	cin >>N;

	for(int i = 0; i < N; i++)
		cin >>a[i];
	sort(a, a+N);

	long long hack = 0; //해커의 수
	if(a[0] != 1) //가장 명예 점수가 작은 국회의원을 선택하여
	{
		hack = a[0] - 1; //Defile이 반복 되도록 명예 점수를 1로 만듦
		a[0] = 1;
	}

	for(int i = 1; i < N; i++)
		if(a[i-1] < a[i]) //명예 점수가 차이난다면
		{
			hack += a[i] - (a[i-1]+1); //해커로 명예 감소
			a[i] = a[i-1] + 1; //Defile이 이어질 것이니 차이가 1이 나도록 감소시킴
		}

	cout <<hack;
}




/*
N명의 국회의원의 명예 점수가 주어졌을 때 한 번의 Defile로 모든 국회의원을 박탈시키게 하는 문제입니다.
해커 한 명당 국회의원 한 명의 명예 점수를 1씩 감소시킬 수 있는데 최소한의 해커를 고용해야 합니다.
국회의원이 한 명이라도 박탈되면 Defile은 반복되므로 다시 모든 국회의원의 명예 점수는 1씩 감소될 것입니다.

간단하게 생각하면 정렬된 상태의 인접한 국회의원의 명예 점수는 서로 같거나 최대 1까지만 차이가 나야 합니다.
오름차순으로 정렬 후 인접한 두 국회의원의 명예 점수 차이의 -1만큼 해커를 고용하여
명예 점수 차이가 1이 되도록 감소 시키면 해결할 수 있습니다.
*/