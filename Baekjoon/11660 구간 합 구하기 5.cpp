//백준 11660 구간 합 구하기 5
//solved.ac CLASS 4

#include "iostream"

using namespace std;

int T[1025][1025]; //T[i][j]: (1, 1)부터 (i, j)까지 합이 저장
int main()
{
	int N, M; //표의 크기, 합을 구해야 하는 횟수
	cin >>N >>M;

	for(int i = 1; i <= N; i++)
		for(int j = 1; j <= N; j++)
		{
			scanf("%d", &T[i][j]);
			T[i][j] += T[i-1][j] + T[i][j-1] - T[i-1][j-1]; //(i-1, j)와 (i, j-1)의 합을 더하고 두 합의 겹친 부분인 (i-1, j-1)을 빼면 (i, j)까지의 합을 구할 수 있음
		}

	for(int i = 0; i < M; i++)
	{
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		printf("%d\n", T[x2][y2] - T[x1-1][y2] - T[x2][y1-1] + T[x1-1][y1-1]); //(x1, y1)부터 (x2, y2)까지의 합을 출력
	}
}




/*
NxN 크기의 표에 수가 채워져 있을 때, (x1, y1)부터 (x2, y2)까지 합을 M번 구하는 문제입니다.
DP를 이용하여 T[i][j]에 (1, 1)부터 (i, j)까지의 합을 미리 구해두고,
(x1, y1)부터 (x2, y2)까지의 합을 구할 땐 미리 구해둔 합을 이용하여 (1, 1)부터 (x2, y2)까지의 합에 (x1, y1)부터 (x2, y2)까지의 구간에 해당하지 않는 부분을 빼서 해결하였습니다.
입력이 들어올 때의 시간복잡도는 O(N^2)이며 출력할 때의 시간복잡도는 O(M)입니다.
N^2의 크기가 최대일 땐 100만이 넘고 M의 크기가 최대 100만이라 cin과 cout 대신 printf()와 scanf()를 사용하였습니다.
*/