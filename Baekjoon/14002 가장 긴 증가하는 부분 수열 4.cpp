//백준 14002 가장 긴 증가하는 부분 수열 4

#include "iostream"

using namespace std;

int A[1001], length[1001], pre[1001]; //수열, length[i]: A[i]가 마지막으로 포함된 부분 수열의 최대 길이, pre[i]: 부분 수열에서 A[i] 직전에 위치한 수의 인덱스
int main()
{
	int N, ans = 0; //수열 A의 크기, 가장 긴 증가하는 부분 수열의 마지막 수의 위치
	cin >>N;
	for(int i = 1; i <= N; i++)
	{
		cin >>A[i];

		for(int j = 0; j < i; j++) //0번째부터 (i-1)번째까지의 수 중
			if(A[j]<A[i] && length[j]>=length[i]) //입력받은 수보다 작으면서 부분 수열의 길이가 같거나 큰 경우
			{
				length[i] = length[j] + 1; //해당 부분 수열에 입력받은 수를 추가
				pre[i] = j; //해당 부분 수열의 가장 큰 수의 위치 저장
			}

		if(length[i] > length[ans]) //더 긴 부분 수열을 찾은 경우
			ans = i; //위치 갱신
	}

	int st[1000], idx = -1; //스택, 스택의 인덱스
	for(int i = ans; i != 0; i = pre[i]) //부분 수열의 가장 큰 수부터 거꾸로 타고 내려감
		st[++idx] = A[i]; //스택에 저장

	cout <<length[ans] <<endl;
	while(idx >= 0) //스택이 비어있지 않은 경우 반복
		cout <<st[idx--] <<" "; //pop하며 수 출력
}




/*
가장 긴 증가하는 부분 수열 (백준 11053)에서 부분 수열의 길이뿐만 아니라 부분 수열도 출력하는 문제입니다.
이전에 풀었던 문제의 코드에서 A[i]가 포함된 부분 수열에서 A[i] 직전에 위치한 수의 인덱스를 저장하는 배열을 추가하여 부분 수열을 연결합니다.
부분 수열의 가장 큰 수의 위치를 저장하여 부분 수열을 거꾸로 타고 내려가 스택에 저장하고 하나씩 꺼내어 출력하면 부분 수열을 작은 수부터 출력할 수 있습니다.
*/