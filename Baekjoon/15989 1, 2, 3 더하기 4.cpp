//백준 15989 1, 2, 3 더하기 4

#include "iostream"

using namespace std;

int dp[10001] = {0, 1, 2, 3};
int main()
{
	int T, max = 3, p = 1; //p: dp[i]에 더해줄 값
	cin >>T;
	while(T--)
	{
		int n;
		cin >>n;

		if(max < n)
		{
			for(int i = max+1; i <= n; i++)
			{
				if(i%6 == 0)		p++; //i%(1+2+3) == 0: 3으로만 구성된 조합이 추가
				else if(i%6 == 1)	p--; //(i-2)%(1+2+3) == 5: 3으로만 구성된 조합에 아직 2를 붙일 수 없음
				else if(i%6 == 2)	p++; //(i-2)%(1+2+3) == 0: 3으로만 구성된 조합에도 2를 붙일 수 있음

				dp[i] = dp[i-1] + p; //(i-1)조합에 1을 붙여주고, 2와 3으로도 붙임
			}
			max = n;
		}

		cout <<dp[n] <<endl;
	}
}




/*
1, 2, 3 더하기 3(백준 15988) 문제에서 합을 이루고 있는 수의 순서만 다른 것은 같은 것으로 치는 문제입니다.
조건 하나만 추가되었을 뿐인데 체감 난이도가 훨씬 올라간 느낌이었습니다.
25번째 줄 dp[i] = dp[i-1] + p를 설명하자면 dp[i-1]을 더해준 이유는 (i-1)의 조합 그대로 1을 덧붙인 것이고,
p는 (i-2)의 조합에서 1이 포함되지 않은 조합에 2를 붙여주고, 만약 i가 3의 배수라면 3으로만 이루어진 조합을 만듭니다.
예를 들어 8의 조합은 7의 조합(1111111, 211111, 31111, 22111, 3211, 2221, 331, 322)에 1을 붙여주고,
6의 조합(111111, 21111, 3111, 2211, 321, 222, 33)에서 1이 포함되지 않은 222와 33에 2를 붙여주는 식으로 조합을 만들 수 있습니다.
*/