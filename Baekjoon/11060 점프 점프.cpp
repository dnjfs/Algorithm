//백준 11060 점프 점프

#include "iostream"

using namespace std;

int main()
{
	int N, miro[1000], jump[1000]; //미로의 크기, miro[i]: i번째 칸에 쓰여 있는 수, jump[i]: i번째 칸까지 가는데 필요한 최소 점프횟수
	cin >>N;
	for(int i = 0; i < N; i++)
	{
		cin >>miro[i];
		jump[i] = 1000; //INF (점프는 최대 999회)
	}

	jump[0] = 0; //시작점
	for(int i = 0; i < N; i++)
		for(int j = 0; j < i; j++)
			if(j+miro[j] >= i && jump[j] < jump[i]) //j번째 칸에서 i번째 칸에 점프하여 도달할 수 있으며, 그랬을 경우 점프횟수가 더 작은 경우
				jump[i] = jump[j]+1; //j번째 칸에서 i번째 칸으로 점프

	if(jump[N-1] < 1000) //가장 오른쪽 끝으로 도달할 수 있음
		cout <<jump[N-1];
	else
		cout <<-1;
}




/*
미로의 각 칸에 정수가 쓰여있을 때, 해당 칸의 크기 이하만큼 오른쪽으로 점프하여 가장 오른쪽 끝으로 가는데 최소 몇 번 점프를 해야 하는지 구하는 문제입니다.
DP를 이용하여 각 칸에 도달하는데 필요한 최소 점프횟수를 저장하여 간단하게 해결하였습니다.
N의 최대 크기가 1000이라 O(N^2)의 시간복잡도로 해결할 수 있었습니다.

조금 더 빠른 방법으로 O(N*A) (A는 칸에 쓰일 수 있는 최댓값)의 시간복잡도로 해결할 수 있는데,
i번째 칸의 값을 입력받으면 현재 칸에서 입력받은 값만큼 미로를 점프해보며 최소 점프횟수를 갱신해나가는 방법도 있습니다.
*/ 
