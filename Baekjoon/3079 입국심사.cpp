//백준 3079

#include "iostream"
#include "algorithm"

using namespace std;

int main()
{
	int N, M, T[100000], maxT = 0; //심사대 수, 친구 수, 심사에 드는 시간, 심사하는데 가장 긴 시간
	cin >>N >>M;
	for(int i = 0; i < N; i++)
	{
		cin >>T[i];
		maxT = max(maxT, T[i]);
	}

	unsigned long long l = 0, r = (long long)maxT*M, m, sum; //이진탐색 구간의 왼쪽, 오른쪽(최악의 경우 시간), 현재 시간, 현재 시간까지 심사대에 통과하는 사람의 수
	while(l <= r) //구간을 모두 탐색할 때까지 반복
	{
		m = (l+r)/2, sum = 0;
		for(int i = 0; i < N; i++)
			sum += m/T[i]; //m만큼의 시간이 지날 때 심사대 T(i)를 통과하는 사람의 수를 몫으로 구함(더 빠른 심사대를 알아서 찾음)

		if(M > sum) //시간이 부족하여 심사대를 통과하는 사람의 수가 부족함
			l = m+1;
		else //시간이 충분함
			r = m-1;
	}

	cout <<l;
}


/*
입국심사대의 심사 시간들이 주어질 때 모든 친구들이 심사대에 통과하는 시간의 최솟값을 구하는 문제입니다.
이진탐색을 사용해야하는 건 알았지만 아이디어가 떠오르지 않아 구글링으로 풀이방법을 참고하였습니다.

현재까지 m만큼의 시간이 지났을 때, 심사대를 통과한 사람의 수를 sum으로 구하였습니다.
현재 시간 m에 심사대의 심사 시간을 나누어 나온 몫은 현재까지 해당 심사대를 통과한 사람의 수와 같습니다.
모든 심사대에 대하여 위와 같은 계산을 하면 sum이 나오는데 모든 친구들이 다 통과하지 못하면
이진탐색 구간의 l을 증가시키고, 친구들이 모두 통과하거나 더 통과하면 r을 감소시킵니다.

이렇게 반복하여 구간을 좁혀나가 반복문을 빠져나오면 정답은 l에 저장되게 됩니다.
왜냐하면 l과 r이 같은 경우엔 구간을 모두 탐색한 경우이므로 l과 r이 정답일 수밖에 없고,
정답을 찾았으니 else문에서 r이 m-1로 감소하여 r을 정답으로 출력할 순 없습니다.
l과 r이 다른 경우로 만약 l이 0이고 r이 1이면 m의 값은 (0+1)/2 = 0이 될텐데,
이때 r이 정답이면 l은 m+1으로 초기화되어 l은 1이 되어 다시 l과 r이 같은 경우가 되고,
l이 정답이면 r은 m-1로 초기화되어 r이 -1라 l을 그대로 출력하면 됩니다.

r을 maxT*M으로 초기화시켜준 이유는 최악의 경우, 심사에 가장 오래 걸리는 시간에 모든 사람이 통과해야되는 시간입니다.
long long int지만 10^14로 초기화시키면 오버플로우가 발생한다고 하여 직접 구간을 지정해줬습니다.

풀고 나니 어제 풀었던 문제와 틀이 크게 다르지 않다는 것에서 충격을 받았습니다.
그리고 정답을 따로 저장하지 않고 l을 바로 출력하는 이유가 제대로 설명이 안되어 있어서
스스로 납득하려 하다보니 설명이 길어지게 되었는데 이진탐색과 관련된 문제는 앞으로 헷갈리지 말아야겠습니다.
시간복잡도는 O(N * log(maxT*M))입니다.
*/

/*
- 2023.09.09 추가 -
T[i]에 모두 1이 들어간 경우 sum의 값은 최대 10^19가 들어갈 수 있습니다.
long long으론 오버플로우가 발생하므로 부호가 없는 unsigned long long을 사용하여야 합니다.
이러한 엣지 케이스를 발견하여 문제를 완벽하게 만든 누군가에게 존경심을 표합니다.
*/
