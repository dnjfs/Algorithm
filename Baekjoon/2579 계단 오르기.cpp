//백준 2579 계단 오르기

#include "iostream"
#include "algorithm"

using namespace std;

int stair[302][2]; //stair[i][0]/stair[i][1]: i번째 계단을 연속으로/연속하지 않고 밟아 얻은 점수
int main()
{
	int n, s; //계단의 개수, 계단의 점수
	cin >>n;

	for(int i = 2; i < n+2; i++)
	{
		cin >>s;
		
		stair[i][0] = stair[i-1][1] + s; //연속하지 않고 밟은 계단을 연속으로 밟음
		stair[i][1] = max(stair[i-2][0], stair[i-2][1]) + s; //연속하지 않고 계단을 밟음
	}

	cout <<max(stair[n+1][0], stair[n+1][1]); //마지막 계단을 밟았을 때 점수의 최댓값 출력
}




/*
n개의 계단에 점수가 쓰여 있을 때, 한 계단씩 또는 두 계단씩 오르는데 연속으로 3개의 계단을 밟지 않고 마지막 계단을 밟는 점수의 최댓값을 구하는 문제입니다.
포도주 시식(백준 2156) 문제와 유형이 비슷하여 연속하여 밟는지, 연속하지 않고 밟는지를 구분하여 간단하게 해결할 수 있었습니다.

18~19번째 줄을 더 자세히 설명해 드리면 계단은 연속으로 2개까지만 밟을 수 있으므로
연속으로 계단을 밟기 위해서는 연속하지 않고 계단을 밟은 상태에서만 밟을 수 있습니다.
연속하지 않고 계단을 밟을 때는 연속해서 계단을 밟은 상태든지, 연속하지 않고 계단을 밟은 상태든지 상관이 없으므로
둘 중 더 큰 값을 가진 상태에서 연속하지 않고 계단을 밟습니다.
*/