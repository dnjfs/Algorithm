//백준 2193 이친수

#include "iostream"

using namespace std;

int main()
{
	long long b[91] = {0, 1}; //b[i]: i자리 이친수의 개수
	int N;
	cin >>N;

	for(int i = 2; i <= N; i++)
		b[i] = b[i-1] + b[i-2]; //b[i-1]/b[i-2]: i자리 이친수에서 0/1로 끝나는 수

	cout <<b[N];
}




/*
0으로 시작하지 않고, 1이 연속으로 나타나지 않는 이진수인 이친수의 개수를 구하는 문제입니다.
0으로 끝나는 이친수에 0과 1을 붙이고, 1로 끝나는 이친수에 0을 붙이는 방법으로 간단하게 해결할 수 있습니다.

처음에 0과 1로 끝나는 이친수를 나누기 위해 2차원 배열로 구현했는데, 1로 끝나는 이친수는 0으로 끝나는 이친수에만 붙일 수 있고,
0으로 끝나는 이친수는 0과 1로 끝나는 이친수 둘 다 붙일 수 있어 이친수의 개수가 피보나치수열로 증가하는 걸 알 수 있었습니다.
즉 b[i]는 i자리 이친수의 개수인데, b[i-1]은 i자리 이친수의 개수 중 0으로 끝나는 수의 개수고,
b[i-2]는 i자리 이친수의 개수 중 1로 끝나는 수의 개수라 b[i] = b[i-1] + b[i-2]와 같은 식으로 표현했습니다.
*/