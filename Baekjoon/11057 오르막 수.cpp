//백준 11057 오르막 수

#include "iostream"

using namespace std;

int main()
{
	int N, dp[1001][11] = {0}; //수의 길이, dp[i][j]: 길이가 i인 수의 첫째 자릿수가 (9~j)일 때 오르막 수의 개수
	cin >>N;

	for(int i = 0; i < 10; i++)
		dp[0][i] = 1; //길이가 1인 수의 오르막 수 계산을 위해 1로 초기화

	for(int i = 1; i <= N; i++) //자릿수를 증가하며 계산
		for(int j = 9; j >= 0; j--) //첫째 자릿수가 큰 오르막 수부터 계산
			dp[i][j] = (dp[i][j+1] + dp[i-1][j]) % 10007; //오르막 수를 j###으로 나타낼 때

	cout <<dp[N][0];
}




/*
수의 자리가 오름차순을 이루는 수를 오르막 수라 할 때, 길이가 N인 오르막 수의 개수를 구하는 문제입니다.
수는 0으로 시작할 수도 있고 인접한 수가 같아도 오르막 수라는 조건에 유의해야 합니다.
DP를 이용하기 위해 2차원 배열을 만들어 dp[i][j]라 할 때 9번째 줄처럼 오르막 수를 저장하였습니다.
dp[i][j]를 길이가 i인 오르막 수의 첫 번째 수가 j로 나타낼 수 있었지만,
코드의 간결함을 위해 반복 작업을 줄이고자 j가 0으로 갈수록 값이 쌓이도록 했습니다.

17번째 줄을 설명하자면, 길이가 i인 오르막 수를 j###으로 나타낼 때 ###의 첫 번째 자리는 j보다 크거나 같아야 하는데,
j###에서 j를 빼면 길이가 i-1이 되므로 이에 해당하는 오르막 수를 나타내는 값은 dp[i-1][j]입니다.
j가 감소할수록 값이 쌓이도록 직전에 계산한 dp[i][j+1]의 값도 함께 더하며 10007로 나눈 값을 저장해주었습니다.
*/
