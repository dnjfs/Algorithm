//백준 2805

#include "iostream"

using namespace std;

int t[1000000]; //나무 길이
int main()
{
	int N, M; //나무의 수, 가져갈 나무의 길이
	cin >>N >>M;
	for(int i = 0; i < N; i++)
		cin >>t[i];

	int l = 0, r = 1000000000, H; //탐색할 높이의 왼쪽, 오른쪽, 중간
	while(l+1 < r) //탐색 범위가 모두 좁혀질 때까지 반복
	{
		H = (l+r)/2;
		long long sum = 0; //잘린 나무의 길이의 합
		for(int i = 0; i < N; i++)
			if(t[i] > H) //절단기의 높이보다 큰 나무들을 모두 절단
				sum += t[i]-H;

		if(M <= sum) //가져갈 나무보다 더 절단한 경우
			l = H; //절단기의 높이를 높여야 함
		else //부족한 경우
			r = H; //절단기의 높이를 낮춰야 함
	}

	cout <<l; //절단기 높이
}


/*
나무의 길이가 주어질 때 집에 가져갈 만큼의 나무를 자르기 위해 절단기의 높이를 조절하는 문제입니다.
이진 탐색을 이용하여 절단기의 높이를 조절하여 탐색하였습니다.
최소한 M이상 가져가면서 절단기 높이의 최댓값을 구해야 하므로
r은 항상 부족한 경우라 l을 충분한 경우에 최대한 높은 값으로 만들어 출력합니다.
*/