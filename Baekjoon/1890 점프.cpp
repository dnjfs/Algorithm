//백준 1890 점프

#include "iostream"

using namespace std;

int main()
{
	int N, map[100][100] = {0}; //게임판의 크기, 게임판의 각 칸에 적혀있는 수
	long long cnt[100][100] = {1}; //cnt[r][c]: (0, 0) 칸에서 (r, c) 칸으로 갈 수 있는 경로의 개수
	cin >>N;

	for(int r = 0; r < N; r++)
		for(int c = 0; c < N; c++)
		{
			cin >>map[r][c];
			if(cnt[r][c] && map[r][c]) //게임판을 점프하며 해당 칸에 방문한 적 있으면서 종착점이 아닌 경우(점프를 할 수 있음)
			{
				int t = map[r][c];
				if(c+t < N) //게임판의 크기를 벗어나지 않으면
					cnt[r][c+t] += cnt[r][c]; //오른쪽으로 점프하여 경로의 수 증가
				if(r+t < N)
					cnt[r+t][c] += cnt[r][c]; //아래쪽으로 점프
			}
		}

	cout <<cnt[N-1][N-1]; //가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 갈 수 있는 경로의 개수 출력
}




/*
NxN 게임판에 수가 적혀있을 때 가장 왼쪽 위 칸에서 각 칸의 수만큼 점프하여 가장 오른쪽 아래 칸으로 갈 수 있는 경로의 개수를 구하는 문제입니다.
점프는 오른쪽이나 아래쪽으로 할 수 있고, 0은 종착점입니다.
바둑판같은 격자 구조에서 최단 거리의 경로의 개수를 구하는 방법을 응용하여 해결했습니다.
격자 구조와 다른 점은 점프할 칸의 수가 1로 일정하지 않다는 점이므로 칸에 적혀있는 수만큼 점프하며 경로의 개수를 갱신하는 방법을 이용했습니다.
유의할 점으로 문제의 조건에서 경로의 개수는 2^63-1보다 작거나 같다고 하였으니 DP로 경로의 개수를 저장할 배열은 long long 자료형으로 선언했습니다.
*/