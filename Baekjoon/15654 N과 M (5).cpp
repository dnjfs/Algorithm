//백준 15654 N과 M (5)
//solved.ac CLASS 4

#include "iostream"
#include "algorithm"

using namespace std;

int main()
{
	int N, M, num[8]; //자연수의 개수, 출력할 수열의 길이, 입력받은 수
	cin >>N >>M;

	for(int i = 0; i < N; i++)
		cin >>num[i];
	sort(num, num+N);

	int f = 1;
	for(int i = N-M; i > 0; i--) //f = (N-M)!
		f *= i;
	int p = f; //중복된 수열을 출력하지 않기 위해 출력하지 않을 부분의 수열 길이는 (N-M)이므로 이 수열을 나열하는 경우의 수는 (N-M)!
	do
	{
		if(!--p) //중복되지 않는 수열만 출력
		{
			for(int i = 0; i < M; i++) //출력할 수열의 크기는 M
				printf("%d ", num[i]);
			printf("\n");
			p = f; //출력 후 다시 카운팅
		}
	}while(next_permutation(num, num+N)); //순차적으로 순열 나열
}




/*
N과 M (2) (백준 15650) 문제에서 수열의 원소를 입력받는 조건이 추가되고 수열을 오름차순으로 출력해야하는 조건이 제외된 문제입니다.
오름차순 조건이 없으므로 조합이 아닌 순열로 생각해서 해결해야 합니다.
N개의 원소를 순열로 나열하여 첫 M개의 원소를 수열로 출력하게 되면 나머지 (N-M)개의 원소를 순열로 나열하는 경우의 수만큼 중복 수열이 발생합니다.
(N-M)개의 수를 순열로 나열하는 경우의 수는 (N-M)!이므로 N개의 원소가 순열로 나열되었을 때 (N-M)!번에 한 번씩 수열을 출력하면 중복되지 않습니다.

자연수의 개수가 최대 8개밖에 되지 않지만 출력할 수열의 크기가 8이면 출력하는 횟수는
순열의 경우의 수 8!과 수열의 크기 8로 8!*8이라 10만이 훨씬 넘어 속도가 빠른 printf()를 사용해야 합니다.
참고로 중복을 허용하지 않는 STL의 set을 사용하는 간단한 방법도 존재합니다.
*/