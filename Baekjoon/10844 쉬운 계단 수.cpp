//백준 10844 쉬운 계단 수

#include "iostream"
using namespace std;

int main()
{
	int n, f[101][10]; //자릿수, f[i][j]: j로 시작하는 길이가 i인 계단 수의 개수
	cin >>n;

	for(int i = 0; i <= 9; i++) //자릿수가 1인 계단 수는 각각 1개
		f[1][i] = 1;

	for(int i = 2; i <= n; i++)
		for(int j = 0; j <= 9; j++) //첫째 자릿수의 값이 j로 시작
		{
			if(j == 9) //9로 시작할 땐 8로 시작하는 수만 붙일 수 있음
				f[i][j] = f[i-1][j-1];
			else if(j == 0) //0으로 시작할 땐 1로 시작하는 수만 붙일 수 있음 (단 0으로 시작하는 수는 계단 수가 아님)
				f[i][j] = f[i-1][j+1];
			else //그 외의 수로 시작할 땐 아래 위로 1 차이나는 수를 붙임
				f[i][j] = (f[i-1][j-1] + f[i-1][j+1]) % 1000000000;
		}

	int sum = 0;
	for(int i = 1; i <= 9; i++) //길이가 n인 계단 수는 1~9로 시작하는 계단 수의 합
		sum = (sum + f[n][i]) % 1000000000;
	
	cout <<sum;
}




/*
인접한 모든 자릿수의 차이가 1이 나는 수를 계단 수라 할 때 자릿수가 N인 계단 수의 개수를 구하는 문제입니다.
자릿수가 늘어남에 따라 이전에 구한 자릿수를 붙여주기 위해 이차원 배열을 만들어 DP로 해결하였습니다.
1로 시작하는 계단 수를 위해 실제로 계단 수에 포함하진 않지만 0으로 시작하는 계단 수도 함께 구하였습니다.
*/