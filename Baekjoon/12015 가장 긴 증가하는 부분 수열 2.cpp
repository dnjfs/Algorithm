//백준 12015 가장 긴 증가하는 부분 수열 2

#include "iostream"
#include "vector"

using namespace std;

vector<int> C = {0}; //C[i]: 부분 수열의 i번째 자리에 올 수 있는 가장 작은 원소
int main()
{
	int N, a; //수열 A의 크기, A의 원소
	cin >>N;
	for(int i = 0; i < N; i++)
	{
		cin >>a;

		if(a > C.back()) //현재 부분 수열에서 가장 큰 값보다 더 큰 값이 입력된 경우
			C.push_back(a); //부분 수열에 추가(크기도 증가)
		else
		{
			int l = 1, r = C.size()-1, m; //이진탐색 구간
			while(l <= r)
			{
				m = (l+r)/2;

				if(C[m] < a) //현재 가리키는 원소보다 입력받은 값이 더 큰 경우
					l = m+1; //왼쪽 구간 증가
				else //현재 가리키는 원소보다 입력받은 값이 같거나 작은 경우
					r = m-1; //오른쪽 구간 감소
			}
			C[l] = a; //이진탐색으로 찾은 위치에 입력받은 값을 덮어씌우기
		}
	}
	
	cout <<C.size()-1; //부분 수열의 크기 출력
}



/*
11053 가장 긴 증가하는 부분 수열의 두 번째 문제입니다.
N의 크기가 1000에서 1000000으로 증가되었으므로 시간복잡도 O(N^2)의 방법은 시간초과가 발생합니다.
길이를 저장하는 배열 대신 부분 수열에서 해당 위치에 올 수 있는 가장 작은 원소를 저장한 배열을 선언하고,
수열의 원소를 입력받을 때마다 배열을 이진탐색으로 탐색하여 O(N logN)의 시간복잡도로 문제를 해결하였습니다.

C[i]의 원소를 부분 수열의 i번째 자리에 올 수 있는 가장 작은 원소를 저장하며
부분 수열에 들어가는 원소의 크기를 줄여가며 가장 긴 부분 수열을 구할 수 있습니다.
이진탐색에서 구간을 조정하는 조건에서 C[m]과 a가 같을 때 왼쪽 구간을 증가시켜버리면
똑같은 크기의 원소가 부분 수열에 들어가버려 증가하는 수열이 아니게 되어버리는 실수가 발생하므로 조심해야합니다.
*/